Threefish-1024 uses a 1024-bit key and 80 rounds, while Threefish-256 uses a 256-bit key and 72 rounds, making the 1024 variant theoretically more secure against brute-force attacks and potentially offering a slightly higher security margin due to the larger state and additional rounds. However, both remain unbroken in their full forms, with cryptanalysis only succeeding on significantly reduced rounds (e.g., 42/80 for 1024-bit vs. 39/72 for 256-bit), and 256 bits is already considered sufficient for all practical purposes as brute-forcing it is infeasible with current or foreseeable technology. In the context of your app, the difference is negligible unless facing hypothetical future threats like massive quantum computing advances, where larger keys could provide extra resilience.
Compared to AES (typically 256-bit) or ChaCha20 (256-bit), Threefish-1024 is overkill but on par or potentially stronger in design (e.g., ARX-based like ChaCha20, resistant to timing attacks without hardware acceleration needs), while Threefish-256 aligns closely with their security levelsâ€”all unbroken and with high margins. AES and ChaCha20 benefit from more extensive real-world scrutiny and hardware support (e.g., AES-NI for speed), making them "battle-tested" defaults, but Threefish shares modern design advantages with ChaCha20 and was a SHA-3 finalist component, so it's comparably secure for most uses. ChaCha20 often edges out in software performance and side-channel resistance.
